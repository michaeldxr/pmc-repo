package oracle.apps.managedBeanFixer;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;

import java.io.FileOutputStream;

import java.io.FileReader;

import java.io.FileWriter;

import java.io.InputStream;

import java.util.ArrayList;


import oracle.xml.parser.v2.DOMParser;
import oracle.xml.parser.v2.XMLDocument;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.util.HashMap;
import java.util.Iterator;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import oracle.apps.NullEntityResolver;
import oracle.apps.financials.commonModules.spreadsheetHelper.Cell;
import oracle.apps.financials.commonModules.spreadsheetHelper.CellLocation;
import oracle.apps.financials.commonModules.spreadsheetHelper.CellValue;
import oracle.apps.financials.commonModules.spreadsheetHelper.Workbook;
import oracle.apps.financials.commonModules.spreadsheetHelper.Worksheet;
import oracle.apps.financials.commonModules.spreadsheetHelper.XLSXCreator;
import oracle.apps.helpers.Mail;
import oracle.apps.utility.JoesBaseClass;

public class ApplyComponentWrapper extends JoesBaseClass {
    private BufferedWriter diff;

    private Workbook m_myBook;
    Worksheet m_beansSheet;
    Worksheet m_membersSheet;

    int m_currentBeanRow = 2;
    int m_currentMemberRow = 2;
    //[Zeesha] - added for debugging purposes
    boolean bDebug = true;

    public ApplyComponentWrapper(JoesBaseClass.CRAWL_TYPE type) {
        super(type);

        m_myBook = new Workbook("beans");
        m_beansSheet = new Worksheet("beans");
        m_myBook.addWorksheet(m_beansSheet);

        m_membersSheet = new Worksheet("bean_members");
        m_myBook.addWorksheet(m_membersSheet);

        m_beansSheet.addCell(new Cell(new CellLocation("A1"), new CellValue("Reference")));
        m_beansSheet.addCell(new Cell(new CellLocation("B1"), new CellValue("Bean Name")));
        m_beansSheet.addCell(new Cell(new CellLocation("C1"), new CellValue("Scope")));
        m_beansSheet.addCell(new Cell(new CellLocation("D1"), new CellValue("Class Name")));

        m_membersSheet.addCell(new Cell(new CellLocation("A1"), new CellValue("Bean Name")));
        m_membersSheet.addCell(new Cell(new CellLocation("B1"), new CellValue("Serializable")));
        m_membersSheet.addCell(new Cell(new CellLocation("C1"), new CellValue("Member Type")));
        m_membersSheet.addCell(new Cell(new CellLocation("D1"), new CellValue("Member Decl")));
        m_membersSheet.addCell(new Cell(new CellLocation("E1"), new CellValue("Do Wrapper?")));
        m_membersSheet.addCell(new Cell(new CellLocation("F1"), new CellValue("Has Autogenerated Set+Get?")));
        m_membersSheet.addCell(new Cell(new CellLocation("G1"), new CellValue("Reference Count")));
    }


    public void recordBeanInXlsx(String sReference, String sBeanName, String sBeanScope, String sBeanClass) {
        String l1 = getCellLocation(0, m_currentBeanRow);
        String l2 = getCellLocation(1, m_currentBeanRow);
        String l3 = getCellLocation(2, m_currentBeanRow);
        String l4 = getCellLocation(3, m_currentBeanRow);

        m_beansSheet.addCell(new Cell(new CellLocation(l1), new CellValue(sReference)));
        m_beansSheet.addCell(new Cell(new CellLocation(l2), new CellValue(sBeanName)));
        m_beansSheet.addCell(new Cell(new CellLocation(l3), new CellValue(sBeanScope)));
        m_beansSheet.addCell(new Cell(new CellLocation(l4), new CellValue(sBeanClass)));

        m_currentBeanRow++;
    }

    public static void main(String[] args) {
        if (args.length != 3 || args[0] == null || args[1] == null || args[2] == null || args[0].equals("") ||
            args[1].equals("") || args[2].equals("")) {
            System.out.println("Usage:  managedBeanAnalysis.sh <path to your code in ade> <output file name, including path>");
            System.exit(1);
        }

        String sCrawlDir = args[0];
        String sOutpFilename = args[1];
        Boolean bDoADE = new Boolean(args[2]);


        try {
            ApplyComponentWrapper managedBeanAnalysis =
                new ApplyComponentWrapper(JoesBaseClass.CRAWL_TYPE.ADFC_CONFIG);

            if (bDoADE.booleanValue())
                managedBeanAnalysis.startDiffLog();

            managedBeanAnalysis.crawlDirectory(sCrawlDir, bDoADE);
            managedBeanAnalysis.analyzeBeans(bDoADE.booleanValue());

            if (bDoADE.booleanValue())
                managedBeanAnalysis.closeDiffLog();

            FileOutputStream out = null;

            out = new FileOutputStream(sOutpFilename);
            XLSXCreator.create(managedBeanAnalysis.m_myBook, out);

            managedBeanAnalysis.logUsageReport(sCrawlDir);
        } catch (Exception e) {
            e.printStackTrace();
        }


    }


    static int m_problemBeanCount = 0;
    static int m_reviewCount = 0;

    static HashMap<String, String> m_BeanMap = new HashMap<String, String>();
    static ArrayList<String> m_problemBeanList = new ArrayList<String>();

    //    private List<RichCommandMenuItem> menuItems;
    private static final String variableDeclRegEx =
        "((?:public|private|protected|static|final|native|synchronized|abstract|threadsafe|transient)+\\s*)*" +
        whiteSpace + "(" + identifier + whiteSpace + "(?:<(?:" + whiteSpace + identifier + whiteSpace + "(?:,)?" +
        whiteSpace + ")+>" + whiteSpace + ")?)" +
        // next is one or more member names.
        "(" + identifier + "(?:" + whiteSpace + "," + whiteSpace + identifier + whiteSpace + ")*" + ")" + whiteSpace +
        "(?:\\[\\s*\\])?" + "(" + "=" + whiteSpace + "[^{;]*" + whiteSpace + ")?" + ";";

    private static final Pattern variableDeclPattern = Pattern.compile(variableDeclRegEx, Pattern.MULTILINE);


    public void processBean(File fFile, boolean doADE) {
        String fileName = fFile.getName();
        System.out.println("fileName: " + fileName);
        try {

            boolean isSerializable = false;

            ArrayList<String> fixedCode = getCodeAsStrings(fFile);
            boolean fixedSomething = false;


            StringBuffer fileData = new StringBuffer(1000);
            BufferedReader reader = new BufferedReader(new FileReader(fFile));

            char[] buf = new char[1024];
            int numRead = 0;
            while ((numRead = reader.read(buf)) != -1) {
                String readData = String.valueOf(buf, 0, numRead);
                fileData.append(readData);
                buf = new char[1024];
            }

            reader.close();

            String str = fileData.toString();
            String origData = fileData.toString();

            str = removeCommentsAndStrings(str);
            String origDataNoCommentsStrings = str;


            String packageRegEx = "\\s*package.*;\\s*$";
            Pattern packagePattern = Pattern.compile(packageRegEx, Pattern.MULTILINE);
            Matcher m = packagePattern.matcher(str);
            str = m.replaceAll("");


            String importRegEx = "\\s*import.*;\\s*$";
            Pattern importPattern = Pattern.compile(importRegEx, Pattern.MULTILINE);
            m = importPattern.matcher(str);
            str = m.replaceAll("");


            m = classDeclPattern.matcher(str);

            int classDeclCount = 0;


            while (m.find()) {
                int start = m.start(0);
                int end = m.end(0);
                String classDeclString = str.substring(start, end);
                if (classDeclString.contains("Serializable")) {
                    isSerializable = true;
                }

                classDeclCount++;
            }

            // implement serializable
            if (isSerializable == false || classDeclCount > 1) {
                if (applyFix2(fFile, doADE, origData, fixedCode)) {
                    fixedSomething = true;
                    isSerializable = true;
                }
            }

            // If serializable - add serialVersionUID if not present
            if (isSerializable) {
                boolean madeVersionIdFix = addVersionUIDIfReqd(fFile, doADE, origData, fixedCode);
                if (madeVersionIdFix)
                    fixedSomething = true;
            }
            String methodDeclRegEx =
                "(public|private|protected|static|final|native|synchronized|abstract|threadsafe|transient)+\\s*[^({;=]*\\([^)=]*\\)[^{=]*\\{";
            Pattern methodDeclPattern = Pattern.compile(methodDeclRegEx, Pattern.MULTILINE);

            boolean done = false;

            while (!done) {
                m = methodDeclPattern.matcher(str);

                if (m.find()) {
                    int start = m.start(0);
                    int end = m.end(0);

                    int open = 1;

                    int z = end;

                    for (z = end; open > 0 && z < str.length(); z++) {
                        char c = str.charAt(z);
                        if (c == '"') {
                            z++;
                            while ((c = str.charAt(z)) != '"')
                                z++;
                        }
                        if (c == '{')
                            open++;
                        else if (c == '}')
                            open--;
                    }
                    String str1 = str.substring(0, start);
                    String str2 = str.substring(z + 1);
                    str = str1 + str2;
                } else {
                    done = true;
                }
            }

            str = removeBlankLines(str);

            m = variableDeclPattern.matcher(str);
            while (m.find()) {
                String type = m.group(2).trim();
                if (isSerializable(type))
                    continue;

                String modifier = m.group(1);
                String matchedMemberName = m.group(3);

                int start = m.start(0);
                int end = m.end(0);
                String varDeclString = str.substring(start, end);
                if (varDeclString == null || "".equals(varDeclString) || varDeclString.contains("="))
                    continue;

                boolean doWrapper = typeNeedsWrapper(type);

                if (processMember(fFile, fFile.getPath(), doADE, origData, origDataNoCommentsStrings,
                                  matchedMemberName, isSerializable, type, varDeclString, doWrapper, fixedCode))
                    fixedSomething = true;
            }


            if (fixedSomething) {
                if (doADE == false)
                    dumpFixedCode(fixedCode);

                doADE(doADE, fFile, fixedCode);
            } else {
                System.out.println("Bean is OK!");
            }
        } catch (Exception e) {
            e.printStackTrace();
            logException(e);
        }
        //      try
        //      {
        //        Scanner scanner = new Scanner(fFile);
        //        //first use a Scanner to get each line
        //        while ( scanner.hasNextLine() )
        //        {
        //            String str = scanner.nextLine();
        //            System.out.println(str);
        //        }
        //          scanner.close();
        //      }
        //      catch(Exception e)
        //      {
        //          e.printStackTrace();
        //          System.exit(-1);
        //      }
    }

    private boolean processMember(File f, String fname, boolean doADE, String origData,
                                  String origDataNoCommentsStrings, String matchedMemberName, boolean isSerializable,
                                  String type, String varDeclString, boolean doWrapper,
                                  ArrayList<String> fixedCode) throws Exception {
        boolean fixedSomething = false;

        // matchedMemberName may be multiple declarations.
        String idRegEx = identifier;
        Pattern idPattern = Pattern.compile(idRegEx, Pattern.MULTILINE);
        Matcher m = idPattern.matcher(matchedMemberName);

        int i = 0;
        while (m.find()) {
            if (i > 0)
                System.out.println("found a multi decl case.");
            String memberName = matchedMemberName.substring(m.start(), m.end());

            boolean hasAutoGeneratedSetterGetter =
                hasDefaultGet(origDataNoCommentsStrings, type, memberName) && hasDefaultSet(origDataNoCommentsStrings, type, memberName);

            int count = numReferences(origDataNoCommentsStrings, memberName);


            try {
                if (count == 1) {
                    if (applyFix1(f, doADE, origData, type, memberName, fixedCode))
                        fixedSomething = true;
                } else {
                    if (type.startsWith("Rich") || type.startsWith("UIX")) {
                        // Check and see if we need to drop the transient part.
                        if (varDeclString.contains("transient")) {
                            // drop the transient part.
                            String v = applyFix3(f, doADE, origData, type, memberName, varDeclString, fixedCode);
                            if (v.equals(varDeclString) == false) {
                                varDeclString = v;
                                fixedSomething = true;
                            }

                        }

                        if (hasAutoGeneratedSetterGetter && count >= 5) {
                            //rewrite references to use getter
                            System.out.println(m_lastGetSignature);
                            if (applyFix4(f, doADE, origData, type, memberName, varDeclString, m_lastGetSignature,
                                          fixedCode))
                                fixedSomething = true;
                        }

                        if (hasAutoGeneratedSetterGetter) {
                            if (applyFix5(f, doADE, origData, type, memberName, varDeclString, fixedCode))
                                fixedSomething = true;
                        }
                    }
                }
            } catch (Exception e) {
                System.out.println("Error wile trying to applyFix1 for ---> " + f.getAbsolutePath());
                e.printStackTrace();
                logException(e);
            }

            insertMember(fname, isSerializable, type, varDeclString, doWrapper, hasAutoGeneratedSetterGetter, count);

            i++;
        }

        return fixedSomething;
    }

    private void insertMember(String fname, boolean isSerializable, String type, String varDeclString,
                              boolean doWrapper, boolean hasAutoGeneratedSetterGetter, int refCount) {
        String l1 = getCellLocation(0, m_currentMemberRow);
        String l2 = getCellLocation(1, m_currentMemberRow);
        String l3 = getCellLocation(2, m_currentMemberRow);
        String l4 = getCellLocation(3, m_currentMemberRow);
        String l5 = getCellLocation(4, m_currentMemberRow);
        String l6 = getCellLocation(5, m_currentMemberRow);
        String l7 = getCellLocation(6, m_currentMemberRow);


        m_membersSheet.addCell(new Cell(new CellLocation(l1), new CellValue(fname)));
        m_membersSheet.addCell(new Cell(new CellLocation(l2), new CellValue(Boolean.toString(Boolean.FALSE))));
        m_membersSheet.addCell(new Cell(new CellLocation(l3), new CellValue(type)));
        m_membersSheet.addCell(new Cell(new CellLocation(l4), new CellValue(varDeclString)));
        m_membersSheet.addCell(new Cell(new CellLocation(l5), new CellValue(Boolean.toString(doWrapper))));
        m_membersSheet.addCell(new Cell(new CellLocation(l6),
                                        new CellValue(Boolean.toString(hasAutoGeneratedSetterGetter))));
        m_membersSheet.addCell(new Cell(new CellLocation(l7), new CellValue(Integer.toString(refCount))));

        m_currentMemberRow++;
    }


    private static final String sSetterRegex1 = whiteSpace + "public" + whiteSpace + "void" + whiteSpace + "(set";
    private static final String sSetterRegex2 = ")" + whiteSpace + "\\(" + whiteSpace;
    private static final String sSetterRegex3 = whiteSpace + "\\)" + whiteSpace + "\\{" + whiteSpace + "this.";
    private static final String sSetterRegex4 = whiteSpace + "=" + whiteSpace;
    private static final String sSetterRegex5 = whiteSpace + ";" + whiteSpace + "\\}";

    private String getSetRegexFirstLineFalsePositive(String type, String varName) {
        String varNameInitCaps = varName.substring(0, 1).toUpperCase() + varName.substring(1);

        String retVal = sSetterRegex1;
        retVal += identifier;
        retVal += sSetterRegex2;
        retVal += identifier + whiteSpace + varName;
        retVal += whiteSpace + "\\)";

        return retVal;
    }

    private String getSetRegex(String type, String varName) {
        String varNameInitCaps = varName.substring(0, 1).toUpperCase() + varName.substring(1);

        String retVal = sSetterRegex1;
        retVal += varNameInitCaps;
        retVal += sSetterRegex2;
        retVal += type + whiteSpace + identifier;
        retVal += sSetterRegex3;
        retVal += varName;
        retVal += sSetterRegex4;
        retVal += identifier;
        retVal += sSetterRegex5;

        return retVal;
    }


    private String getSetRegexFirstLine(String type, String varName) {
        String varNameInitCaps = varName.substring(0, 1).toUpperCase() + varName.substring(1);

        String retVal = sSetterRegex1;
        retVal += varNameInitCaps;
        retVal += sSetterRegex2;
        retVal += type + whiteSpace + identifier;
        retVal += whiteSpace + "\\)";

        return retVal;
    }

    private boolean hasDefaultSet(String origData, String memberType, String memberName) {
        String sSetRegex = getSetRegex(memberType, memberName);

        Pattern p = Pattern.compile(sSetRegex, Pattern.CASE_INSENSITIVE);
        Matcher m = p.matcher(origData);

        int count = 0;

        while (m.find()) {
            count++;
        }

        return count == 1;
    }


    private static final String sGetterRegex1 = whiteSpace + "public" + whiteSpace;
    private static final String sGetterRegex2 = whiteSpace + "(get";
    private static final String sGetterRegex3 =
        ")" + whiteSpace + "\\(" + whiteSpace + "\\)" + whiteSpace + "\\{" + whiteSpace + "return" + whiteSpace +
        "(:?" + "this\\." + ")?";
    private static final String sGetterRegex4 = whiteSpace + ";" + whiteSpace + "\\}";

    private String getGetRegex(String type, String varName) {
        String varNameInitCaps = varName.substring(0, 1).toUpperCase() + varName.substring(1);

        String retVal = sGetterRegex1;
        retVal += type;
        retVal += sGetterRegex2;
        retVal += varNameInitCaps;
        retVal += sGetterRegex3;
        retVal += varName;
        retVal += sGetterRegex4;

        return retVal;
    }

    private String getGetRegexFirstLine(String type, String varName) {
        String varNameInitCaps = varName.substring(0, 1).toUpperCase() + varName.substring(1);

        String retVal = sGetterRegex1;
        retVal += type;
        retVal += sGetterRegex2;
        retVal += varNameInitCaps;
        retVal += whiteSpace + "\\(" + whiteSpace + "\\))";

        return retVal;
    }

    private String m_lastGetSignature;
    private String m_lastSetSignature;

    private boolean hasDefaultGet(String origData, String memberType, String memberName) {
        m_lastGetSignature = "not determined";

        if (memberName == null || "".equals(memberName))
            return false;
        if (memberType == null || "".equals(memberType))
            return false;

        String sGetRegex = getGetRegex(memberType, memberName);

        Pattern p = Pattern.compile(sGetRegex, Pattern.CASE_INSENSITIVE);
        Matcher m = p.matcher(origData);

        int count = 0;

        if (m.find() == false)
            return false;

        m_lastGetSignature = m.group(1);

        if (m.find()) {
            m_lastGetSignature = "not determined";
            return false;
        }

        return true;
    }

    /**
     * analyzes the problem beans stored in m_problemBeanList:ArrayList<String>, where key is the fullQualifiedClassName
     * @param doADE
     */
    public void analyzeBeans(boolean doADE) {
        Iterator<String> iter = m_problemBeanList.iterator();
        while (iter.hasNext()) {
            String sBeanClass = iter.next();
            System.out.println("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
            System.out.println("Analyzing Bean --> " + sBeanClass);

            String key = sBeanClass.replace(".", "/") + ".java";

            String location = m_BeanMap.get(key);
            System.out.println("location --> " + location);

            if (key == null || location == null || "".equals(key) || "".equals(location)) {
                System.out.println("Review:  unexpected key/location " + key + "  " + location);
                continue;
            }

            File f = new File(location);
            if (f.exists() == false) {
                System.out.println("Error:  can't open bean --> " + location);
                continue;
                /*[Zeesha: commented out.. should continue to process other beans even if this one is corrupt]
                System.exit(-1);*/
            }

            processBean(f, doADE);
        }
    }

    private void registerBean(String sBeanPath) {
        // skip these bad guys
        if (sBeanPath.contains("org/apache/myfaces/trinidad/bean/FacesBean/Type.xml") ||
            sBeanPath.contains("org/apache/myfaces/trinidad/bean/PropertyKey.xml") ||
            sBeanPath.contains("org/apache/myfaces/trinidad/bean/FacesBean.xml"))
            return;

        if (sBeanPath.contains("ce/bankStatements/ui/public_html/TestBean.java"))
            return;

        int index = sBeanPath.indexOf("oracle/");
        if (index < 0) {
            System.out.println(sBeanPath);
            System.exit(-1);
        }

        String key = sBeanPath.substring(index);
        String value = sBeanPath;

        if (m_BeanMap.containsKey(key)) {
            System.out.println("error:  duplicate key");
            System.out.println(key);
            System.out.println(value);
            System.out.println("sBeanPath = " + sBeanPath);
            System.exit(-1);
        }

        m_BeanMap.put(key, value);
    }

    private void registerProblemBean(String sBeanClass) {
        //        // this one doesn't exist.
        //        if(sBeanClass.equals("oracle.apps.financials.cashManagement.reconciliationSetup.ui.bean.ViewRuleSetBean") ||
        //           sBeanClass.equals("oracle.apps.financials.generalLedger.calendars.accounting.ui.bean.CalendarDialogBean"))
        //        {
        //            System.out.println("Need to review --> " +sBeanClass);
        //            return;
        //        }

        //        if(sBeanClass.contains("bean") == false && sBeanClass.contains("Bean") == false)
        //        {
        //            if(sBeanClass.contains("InvoiceContextualAreaStateUtil") ||
        //               sBeanClass.contains("ExmSearchContextualEvent")) {
        //                // skip this one
        //            }
        //            else
        //            {
        //                System.out.println("bean named incorrectly");
        //                System.out.println(sBeanClass);
        //                System.exit(-1);
        //            }
        //        }


        m_problemBeanCount++;

        boolean inList = false;
        for (int k = 0; !inList && k < m_problemBeanList.size(); k++) {
            if (m_problemBeanList.get(k).equals(sBeanClass))
                inList = true;
        }
        if (!inList)
            m_problemBeanList.add(sBeanClass);
    }

    //    private void investigateBean(String srcPath, String sBeanClass)
    //    {
    //        int index = srcPath.indexOf("public_html");
    //        srcPath = srcPath.substring(0, index);
    //
    //        String rest = sBeanClass.replace(".", "/");
    //
    //        String sFileName1 = srcPath +"src/" +rest +".java";
    //        String sFileName2 = srcPath +"adfmsrc/" +rest +".java";
    //
    //        File f1 = new File(sFileName1);
    //        if(f1.exists() == true)
    //            return;
    //
    //        File f2 = new File(sFileName2);
    //        if(f2.exists() == true)
    //            return;
    //
    //            System.out.println("Error file does not exist. --> " +sFileName1);
    //            System.out.println("Error file does not exist. --> " +sFileName2);
    //            System.exit(-1);
    //    }

    private void processADFC_CONFIG(File f) {
        System.out.println("Processing adfc_config filename: " + f.getName());
        try {
            DOMParser parser = new DOMParser();
            parser.setErrorStream(System.out);
            parser.setEntityResolver(new NullEntityResolver());
            parser.showWarnings(true);
            parser.setValidationMode(DOMParser.NONVALIDATING);

            parser.parse("file:" + f.getCanonicalPath());

            XMLDocument doc = parser.getDocument();
            NodeList adfc = doc.getElementsByTagName("adfc-config");
            if (adfc == null) {
                System.out.println("Not an adfc-config file ---> " + f.getCanonicalPath());
            }
            NodeList beanList = doc.getElementsByTagName("managed-bean");

            for (int i = 0; i < beanList.getLength(); i++) {
                Node bean = beanList.item(i);
                NodeList beanChildren = bean.getChildNodes();

                String sScope = "not set";
                String sBeanName = "not set";
                String sBeanClass = "not set";

                for (int j = 0; j < beanChildren.getLength(); j++) {
                    Node child = beanChildren.item(j);
                    if (child.getNodeName().equals("managed-bean-scope")) {
                        sScope = child.getTextContent().trim();
                    } else if (child.getNodeName().equals("managed-bean-name")) {
                        sBeanName = child.getTextContent().trim();
                    } else if (child.getNodeName().equals("managed-bean-class")) {
                        sBeanClass = child.getTextContent().trim();
                    }

                }

                if (!sScope.equals("pageFlow") && !sScope.equals("session") && !sScope.equals("view") &&
                    !sScope.equals("request") && !sScope.equals("none") && !sScope.equals("backingBean")) {
                    System.out.println("Scope is --->" + sScope);
                    System.out.println("ERROR:  unexpected scope");
                    //System.exit(-1);
                    // [Zeesha] Even if there is an unexpected scope can still continue processing the other managed beans in this flow
                    continue;
                }

                if (sBeanClass.equals("java.lang.String") || sBeanClass.equals("java.util.HashMap") ||
                    sBeanClass.startsWith("oracle.bpel."))
                    continue;

                // only review stateful.
                if ("pageFlow".equals(sScope) == false && "session".equals(sScope) == false &&
                    "view".equals(sScope) == false) {

                    //return;
                    //[Zeesha] - should continue to process other beans in this file
                    continue;
                }

                if (sBeanClass.startsWith("oracle.apps.fnd")) {
                    //return;
                    //Zeesha - should continue to process other beans
                    continue;
                }

                recordBeanInXlsx(f.getName(), sBeanName, sScope, sBeanClass);
                registerProblemBean(sBeanClass);
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(0);
            logException(e);
        }

    }


    private boolean isSerializable(String type) {
        if (type == null || "".equals(type))
            return true;

        // These are ok.
        if ("Boolean".equals(type) || "String".equals(type) || "BigDecimal".equals(type) || "int".equals(type) ||
            "Integer".equals(type) || "Long".equals(type) || "Object".equals(type) || "boolean".equals(type) ||
            "List".equals(type) || "HashMap".equals(type) || "Double".equals(type) || "ArrayList".equals(type) ||
            "Date".equals(type) || "Key".equals(type) || "Map".equals(type) || "HashSet".equals(type) ||
            "Hashtable".equals(type) || "byte".equals(type) || "long".equals(type) || "Timestamp".equals(type))
            return true;

        return false;
    }


    private String removeCommentsAndStrings(String str) {
        boolean clean = false;

        for (int i = 0; i < str.length() - 1; i++) {
            char c1, c2;
            c1 = str.charAt(i);
            c2 = str.charAt(i + 1);

            if (c1 == '/' && c2 == '*') {
                int start = i;
                /* remove /* blah blah style comment. */

                while (str.charAt(i) != '*' || str.charAt(i + 1) != '/')
                    i++;

                str = str.substring(0, start) + str.substring(i + 2);

                i = start - 1;
                if (i < 0)
                    i = 0;
                continue;
            }

            if (c1 == '/' && c2 == '/') {
                // remove // style comment.
                int start = i;
                /* remove /* blah blah style comment. */
                while (str.charAt(i) != '\n')
                    i++;

                str = str.substring(0, start) + str.substring(i + 1);
                i = start - 1;
                if (i < 0)
                    i = 0;
                continue;

            }

            if (c1 == '"') {
                // remove string.
                int start = i++;
                /* remove "blah" strings. */
                while (str.charAt(i) != '"' || str.charAt(i - 1) == '\\')
                    i++;

                str = str.substring(0, start) + str.substring(i + 1);
                i = start - 1;
                if (i < 0)
                    i = 0;
                continue;
            }

            if (c1 == '\'') {
                // remove character cause it could be a quote
                int start = i++;
                /* remove 'x' characters but whatch for escape. */
                while (str.charAt(i) != '\'' || str.charAt(i - 1) == '\\')
                    i++;

                str = str.substring(0, start) + str.substring(i + 1);
                i = start - 1;
                if (i < 0)
                    i = 0;
                continue;
            }

        }

        return str;
    }


    private boolean typeNeedsWrapper(String type) {
        if (type == null || "".equals(type))
            return false;

        if (type.startsWith("Rich") || type.startsWith("UIX"))
            return true;

        return false;
    }

    private static final String blankLineRegex = "^[ \\t\\r\\f\\x0B]*\n";
    private static final Pattern blankLinePattern = Pattern.compile(blankLineRegex, Pattern.MULTILINE);

    private String removeBlankLines(String str) {
        Matcher m = blankLinePattern.matcher(str);
        str = m.replaceAll("");
        return str;
    }

    private int numReferences(String code, String identifier) {
        String r = "(:?[\\s\\.\\)\\(=+-/*,\\[])" + identifier + "(:?[\\s;\\)=+-/*,\\]\\.])";
        Pattern p = Pattern.compile(r, Pattern.MULTILINE);

        Matcher m = p.matcher(code);

        int count = 0;
        while (m.find()) {
            count++;
        }

        return count;
    }


    private static final String classDeclRegEx =
        "(public|private|protected|static|final|native|synchronized|abstract|threadsafe|transient)*\\s*class" +
        requiredWhiteSpace + "(" + identifier + ")" + whiteSpace + "[^{]*" + whiteSpace + "\\{";
    private static final Pattern classDeclPattern = Pattern.compile(classDeclRegEx, Pattern.MULTILINE);

    private static final String importSerRegEx = "import" + whiteSpace + "java\\.io\\.Serializable" + whiteSpace + ";";
    private static final Pattern importSerPattern = Pattern.compile(importSerRegEx, Pattern.MULTILINE);

    private static final String importComRefRegEx =
        "import" + whiteSpace + "org\\.apache\\.myfaces\\.trinidad\\.util\\.ComponentReference" + whiteSpace + ";";
    private static final Pattern importComRefPattern = Pattern.compile(importComRefRegEx, Pattern.MULTILINE);

    private static final String importRegEx = "import" + whiteSpace + "[^;]*" + whiteSpace + ";";
    private static final Pattern importPattern = Pattern.compile(importRegEx, Pattern.MULTILINE);

    // Fix 2 is having the class implement Serializable.

    private boolean applyFix2(File f, boolean doADE, String origData, ArrayList<String> fixedCode) throws Exception {
        boolean fixedSomething = false;

        boolean hasSerImport = false;
        int firstImportIndex = -1;
        int seen = 0;

        Matcher serMatcher = importSerPattern.matcher(origData);
        if (serMatcher.find())
            hasSerImport = true;

        Matcher importMatcher = importPattern.matcher(origData);
        if (importMatcher.find())
            firstImportIndex = importMatcher.start();

        String line;
        Iterator<String> iter = fixedCode.iterator();
        int index = 0;

        while (iter.hasNext()) {
            line = iter.next();


            int len = line.length() + newline.length();

            // inject import java.io.Serializable
            if (hasSerImport == false && (seen + len) > firstImportIndex) {
                int injectionPoint = firstImportIndex - seen;
                line =
line.substring(0, injectionPoint) + "import java.io.Serializable;" + newline + line.substring(injectionPoint);
                fixedCode.set(index, line);
                fixedSomething = true;

                hasSerImport = true;
            }

            // mark class serializable
            Matcher m = classDeclPattern.matcher(line);
            if (m.find()) {
                String sClassName = m.group(2);

                if (line.contains("implements") && line.contains("Serializable"))
                    return fixedSomething;

                line = markClassSerializable(line, sClassName);
                fixedCode.set(index, line);

                return fixedSomething;
            }

            index++;
            seen += len;
        }

        return fixedSomething;
    }


    private static final String extendsRegEx =
        "extends" + requiredWhiteSpace + identifier + "(:?" + whiteSpace + "," + whiteSpace + identifier + ")*";
    private static final Pattern extendsPattern = Pattern.compile(extendsRegEx, Pattern.MULTILINE);


    private String markClassSerializable(String line, String sClassName) {
        boolean hasExtends = false;
        if (line.contains("extends"))
            hasExtends = true;

        boolean hasImplements = false;
        if (line.contains("implements"))
            hasImplements = true;

        if (hasImplements) {
            String replace = line.replaceFirst(" implements", " implements Serializable,");
            return replace;
        }

        if (hasExtends) {
            Matcher m = extendsPattern.matcher(line);
            if (m.find()) {
                int injectionPoint = m.end();
                line =
line.substring(0, injectionPoint) + " implements Serializable " + line.substring(injectionPoint);
                return line;
            } else {
                System.out.println("Error:  coudle not process this case for marking the class serializable:   " +
                                   line);
                return line;
            }
        }

        String replace = line.replaceFirst(sClassName, sClassName + " implements Serializable");
        return replace;
    }


    // Fix 1 drops unused private Rich/UIX members.

    private boolean applyFix1(File f, boolean doADE, String origData, String varType, String varName,
                              ArrayList<String> fixedCode) throws Exception {
        int seen = 0;
        boolean fixedLine = false;

        String r = whiteSpace + "private" + whiteSpace + varType + whiteSpace + varName + whiteSpace + ";";
        Pattern p = Pattern.compile(r, Pattern.MULTILINE);

        Matcher m = p.matcher(origData);

        if (m.find() == false) {
            System.out.println("Error:  tried to remove unused variable, but could not find it... \n" +
                    f.getAbsolutePath() + "\nvarName = " + varName);
            return false;
        }

        String textToRemove = origData.substring(m.start(), m.end()).trim();

        if (m.find()) {
            System.out.println("Error:  tried to remove unused variable, but found more than one reference to it.\n" +
                    f.getAbsolutePath() + "\nvarName = " + varName);
            return false;
        }


        String line;
        Iterator<String> iter = fixedCode.iterator();

        while (iter.hasNext() && fixedLine == false) {
            line = iter.next();

            if (fixedLine == false && line.contains(textToRemove)) {
                if (line.trim().equals(textToRemove)) {
                    fixedLine = true;
                    iter.remove();
                    continue;
                } else {
                    System.out.println("Error could not remove the unreferenced variable...");
                    System.out.println("textToRemove ---> " + textToRemove);
                    System.out.println("line         ---> " + line);
                    throw new Exception("Error:  could not remove member declaration from this line --> " + line);
                }
            }
        }


        if (fixedLine) {
            System.out.println("+++ Fix #1 Applied ++++++++++++++++++++++++++++++++++++++++++++++++++++");
            return true;
            //System.out.println(sb);
        } else {
            System.out.println("Review: could not drop unused private Rich/UIX members ---> " + varName + " in file " +
                               f.getAbsolutePath());
        }

        return false;
    }


    // Fix 3 is dropping transient modifier from Rich/UIX members.

    private String applyFix3(File f, boolean doADE, String origData, String varType, String varName, String varDecl,
                             ArrayList<String> fixedCode) throws Exception {
        int lineNo = 0;
        int seen = 0;
        boolean fixedLine = false;

        String r1 =
            whiteSpace + "(transient" + whiteSpace + ")private" + whiteSpace + varType + whiteSpace + varName + whiteSpace +
            ";";
        String r2 =
            whiteSpace + "private(" + whiteSpace + "transient)" + whiteSpace + varType + whiteSpace + varName + whiteSpace +
            ";";

        if (varDecl.indexOf("transient") > varDecl.indexOf("private"))
            r1 = r2;

        Pattern p = Pattern.compile(r1, Pattern.MULTILINE);

        Matcher m = p.matcher(origData);

        if (m.find() == false) {
            System.out.println("Error:  tried to find transient variable, but could not find it... \n" +
                    f.getAbsolutePath() + "\nvarName = " + varName);
            return varDecl;
        }

        String variableToModify = origData.substring(m.start(), m.end()).trim();
        String textToRemove = m.group(1);

        if (m.find()) {
            System.out.println("Error:  tried to find transient variable, but found more than one declaration.\n" +
                    f.getAbsolutePath() + "\nvarName = " + varName);
            return varDecl;
        }


        String line;
        Iterator<String> iter = fixedCode.iterator();

        while (iter.hasNext()) {
            line = iter.next();

            int len = line.length() + newline.length();
            seen += line.length() + newline.length();

            if (fixedLine == false && line.contains(variableToModify)) {
                int first = line.indexOf(textToRemove);
                int last = line.lastIndexOf(textToRemove);
                if (first == last) {
                    line = line.substring(0, first) + line.substring(first + textToRemove.length());
                    fixedCode.set(lineNo, line);

                    varDecl = varDecl.replaceFirst(textToRemove, "");

                    System.out.println("+++ Fix #3 Applied ++++++++++++++++++++++++++++++++++++++++++++++++++++");
                    return varDecl;
                } else {
                    System.out.println("Error could not remove the unreferenced variable...");
                    System.out.println("textToRemove ---> " + textToRemove);
                    System.out.println("line         ---> " + line);
                    return varDecl;
                }
            }

            lineNo++;
        }


        System.out.println("Review:  could drop the transient modifier ---> " + varDecl + " in file ---> " +
                           f.getAbsolutePath());
        return varDecl;
    }


    private Matcher getMethodParamMatcher(String varName, String line) {
        String methodParamRegex = identifier + requiredWhiteSpace + varName + whiteSpace + "(,|\\))";
        Pattern methodParamPattern = Pattern.compile(methodParamRegex);

        return methodParamPattern.matcher(line);
    }

    private Matcher getLocalVariableMatcher(String varName, String line) {
        String localRegex = identifier + requiredWhiteSpace + varName + whiteSpace + "(;|=)";
        Pattern localPattern = Pattern.compile(localRegex);

        return localPattern.matcher(line);
    }


    // Fix 4 is rewriting direct references to use getter.

    private boolean applyFix4(File f, boolean doADE, String origData, String varType, String varName, String varDecl,
                              String getSignature, ArrayList<String> fixedCode) throws Exception {
        int seen = 0;
        int lineNo = 0;

        boolean hasFix = false;
        boolean inComment = false;
        boolean lineIsComment = false;

        String r =
            "(:?this" + whiteSpace + ")?" + "(:?[\\s\\.\\)\\(=+-/*,\\[])" + varName + "(:?[\\s;\\)+-/*,\\]\\.])";
        Pattern p = Pattern.compile(r, Pattern.MULTILINE);


        String setRegexFalsePositive = getSetRegexFirstLineFalsePositive(varType, varName);
        Pattern setPatternFalsePositive = Pattern.compile(setRegexFalsePositive, Pattern.CASE_INSENSITIVE);

        String setRegex = getSetRegexFirstLine(varType, varName);
        Pattern setPattern = Pattern.compile(setRegex, Pattern.CASE_INSENSITIVE);


        String getRegex = getGetRegexFirstLine(varType, varName);
        Pattern getPattern = Pattern.compile(getRegex, Pattern.CASE_INSENSITIVE);


        String line = null;
        Iterator<String> iter = fixedCode.iterator();

        boolean currentLineIsSetGet = false;
        boolean prevLineIsSetGet = false;
        boolean prevLineIsSetGetAndHadCurly = true;
        boolean prevLineHadSemicolon = false;

        boolean localVarMatchesVarName = true;
        boolean methodParameterMatchesVarName = true;
        boolean hasSeenOneCurly = false;
        int curlyCount = 0;

        String extraCommentAtEndOfCode = null;


        while (iter.hasNext()) {
            if (line != null)
                prevLineHadSemicolon = line.contains(";");

            line = iter.next();
            String origLine = line;
            int len = line.length() + newline.length();
            seen += line.length() + newline.length();

            extraCommentAtEndOfCode = null;
            if (line.contains("//")) {
                Matcher m = lineCommentPattern.matcher(line);
                if (m.find()) {
                    if (m.group().trim().equals(line.trim()))
                        lineIsComment = true;
                    else {
                        extraCommentAtEndOfCode = m.group();
                        line = line.substring(0, m.start());
                    }
                }
            }

            if (methodParameterMatchesVarName || localVarMatchesVarName) {
                if (line.contains("{")) {
                    curlyCount++;
                    hasSeenOneCurly = true;
                }
                if (line.contains("}"))
                    curlyCount--;

                if (curlyCount <= 0) {
                    localVarMatchesVarName = false;
                    methodParameterMatchesVarName = false;
                    hasSeenOneCurly = false;
                    curlyCount = 0;
                }
            }

            // potential reference
            if (!lineIsComment && !inComment && line.toLowerCase().contains(varName.toLowerCase()) &&
                line.trim().contains(varDecl.trim()) == false) {

                if (setPattern.matcher(line).find() || getPattern.matcher(line).find()) {
                    currentLineIsSetGet = true;
                    prevLineIsSetGetAndHadCurly = line.contains("{");
                } else
                // look for cases where the varName is the set parameter
                if (setPatternFalsePositive.matcher(line).find()) {
                    currentLineIsSetGet = true;
                    prevLineIsSetGetAndHadCurly = line.contains("{");
                } else {
                    Matcher m = getMethodParamMatcher(varName, line);
                    if (m.find()) {
                        // ok, this varname matches a method parameter declaration!
                        methodParameterMatchesVarName = true;
                        hasSeenOneCurly = false;
                        curlyCount = 0;
                        if (line.contains("{")) {
                            curlyCount++;
                            hasSeenOneCurly = true;
                        }
                    } else {
                        // check for local variable match
                        Matcher m2 = getLocalVariableMatcher(varName, line);
                        if (m2.find() && line.contains("return") == false) {
                            localVarMatchesVarName = true;
                            hasSeenOneCurly = true;
                            curlyCount = 1;
                        }

                    }
                }


                if (localVarMatchesVarName == false && methodParameterMatchesVarName == false &&
                    currentLineIsSetGet == false && prevLineIsSetGet == false) {
                    Matcher matcher = p.matcher(line);
                    int matches = 0;
                    while (matcher.find()) {
                        matches++;
                        int s = matcher.start();
                        int e = matcher.end();

                        String reference = line.substring(s, e);

                        if (reference.contains("this") == false)
                            s++;

                        e--;


                        line = line.substring(0, s) + getSignature + "()" + line.substring(e);
                        if (extraCommentAtEndOfCode == null)
                            fixedCode.set(lineNo, line);
                        else
                            fixedCode.set(lineNo, line + extraCommentAtEndOfCode);
                        if (bDebug) {
                            System.out.println("-->[Applyfix4]");
                            System.out.println("Orig line: " + origLine);
                            System.out.println("New line: " + line);
                            System.out.println("<--[end: Applyfix4]");
                        }
                        hasFix = true;

                        // try again...
                        matcher = p.matcher(line);
                    }

                    if (matches == 0) {
                        //System.out.println("close potential reference ---> " + line);
                    }
                }

            }

            lineNo++;
            lineIsComment = false;

            if (prevLineIsSetGet && prevLineIsSetGetAndHadCurly == false) {
                // need to skip one line
                prevLineIsSetGetAndHadCurly = true;
            } else {
                if (currentLineIsSetGet || prevLineHadSemicolon == true)
                    prevLineIsSetGet = currentLineIsSetGet;
            }
            currentLineIsSetGet = false;
        }

        if (hasFix) {
            System.out.println("+++ Fix #4 Applied ++++++++++++++++++++++++++++++++++++++++++++++++++++");
            return true;
        }

        return false;
    }

    /**
     * This method adds the serialVersionUID for the serializable class.
     * This is for performance reasons so that we dont have the framework calculating the uid for us.
     * @return
     */
    private boolean addVersionUIDIfReqd(File f, boolean doADE, String origData, ArrayList<String> fixedCode) {

        String versionUidMemberName = "serialVersionUID";
        String versionUidDecl = "private static final long " + versionUidMemberName + " = 1;";

        if (containsMemberName(origData, versionUidMemberName)) {
            if (bDebug) {
                System.out.println("Member name already present");
            }
            return false;
        }

        Iterator<String> fixedCodeIter = fixedCode.iterator();
        int index = 0;


        String variablePadding = "";
        String changedLine = "";
        int endClassIndex = -1;
        int lineIndex = 0;
        boolean serializedClassFound = false;

        while (fixedCodeIter.hasNext()) {
            String line = fixedCodeIter.next();
            Matcher classMatcher = classDeclPattern.matcher(line);
            if (classMatcher.find()) {

                if (line.contains("implements") && line.contains("Serializable")) {
                    endClassIndex = classMatcher.end();
                    lineIndex = index;
                    serializedClassFound = true;
                }

            } else if (!isEmpty(line) && serializedClassFound) {
                variablePadding = getWhiteSpacePrefix(line);
                break;
            }
            index++;

        }
        if (!serializedClassFound) {
            System.out.println("serializable class not found");
            return false;
        }
        // add it as the first member. Get class declaration {, add as next line to this
        // e.g. { \n private static final long serialVersionUID=1;
        String lineToChange = fixedCode.get(lineIndex);
        changedLine = lineToChange.substring(0, endClassIndex);
        changedLine = changedLine + newline + variablePadding + versionUidDecl;
        changedLine = changedLine + lineToChange.substring(endClassIndex);
        fixedCode.set(lineIndex, changedLine);
        if (bDebug) {
            System.out.println("-->[addVersionUIDIfReqd:Start]");
            System.out.println("OldLine: " + lineToChange);
            System.out.println("NewLine: " + changedLine);
            System.out.println("<--[addVersionUIDIfReqd:End]");
        }

        return true;

    }

    public boolean isEmpty(String str) {
        if (str == null || str.trim().equals(""))
            return true;
        return false;
    }

    private boolean containsMemberName(String data, String memberName) {


        Matcher m = getLocalVariableMatcher(memberName, data);
        if (m.find()) {
            return true;
        }
        /* while (m.find()) {
            String type = m.group(2).trim();
            String modifier = m.group(1);
            String matchedMemberName = m.group(3);
            if (!isEmpty(matchedMemberName) &&
                matchedMemberName.trim().equals(memberName)) {
                return true;
            }
            return true;
        }*/
        return false;
    }

    // Fix 5 applies the wrapper.

    private boolean applyFix5(File f, boolean doADE, String origData, String varType, String varName, String varDecl,
                              ArrayList<String> fixedCode) throws Exception {
        int lineNo = 0;
        int seen = 0;
        boolean fixedDecl = false;
        boolean hasImport = false;

        boolean fixNextLineForGet = false;
        boolean isGetterFixed = false;

        boolean fixNextLineForSet = false;
        boolean isSetterFixed = false;

        String line;
        Iterator<String> iter = fixedCode.iterator();
        // we want to change the component reference name to the varName+'Ref'
        String varRefName = varName + "Ref";

        while (iter.hasNext()) {
            line = iter.next();

            int len = line.length() + newline.length();
            seen += line.length() + newline.length();


            if (importComRefPattern.matcher(line).find())
                hasImport = true;

            if (hasImport == false) {
                if (importPattern.matcher(line).find()) {
                    line = "import org.apache.myfaces.trinidad.util.ComponentReference;" + newline + line;
                    fixedCode.set(lineNo, line);
                    hasImport = true;
                }
            }

            if (fixedDecl == false && line.contains(varDecl)) {
                int commentsIndex = line.indexOf("//");
                if (commentsIndex == -1)
                    commentsIndex = line.length();

                if (varDecl.trim().equals(line.substring(0, commentsIndex).trim())) {
                    // Zeesha : adding this check because some members have public type. This throws index
                    // out of bounds.. very bad way to fix, but dont want to destabilize code
                    // by  making any drastic changes
                    String accessType = "private";
                    if (line.contains("private ")) {
                        accessType = "private";
                    } else if (line.contains("public")) {
                        accessType = "public";
                    } else if (line.contains("protected")) {
                        accessType = "protected";
                    }
                    String prefixPadding = getWhiteSpacePrefix(line);
                    //int padding = line.indexOf("private");


                    int semicolon = line.indexOf(";");
                    String origLine = line;
                    /*line =
line.substring(0, padding) + "private ComponentReference<" + varType + "> " + varRefName + line.substring(semicolon);*/

                    line =
prefixPadding + accessType + " ComponentReference<" + varType + "> " + varRefName + line.substring(semicolon);
                    fixedCode.set(lineNo, line);
                    if (bDebug) {
                        System.out.println("--> [Applying Component Wrapper]:");
                        System.out.println("Old line: " + origLine);
                        System.out.println("New Line: " + line);
                        System.out.println("<-- [End:Applying Component Wrapper]");
                    }
                    fixedDecl = true;
                } else {
                    System.out.println("Error could not remove the unreferenced variable...");
                    System.out.println("line         ---> " + line);
                    throw new Exception("Could not rewrite this member/line:  " + varName + " : " + line);
                }
            }

            if (isGetterFixed == false) {
                if (fixNextLineForGet == false) {
                    // in scanning mode
                    String getRegEx = getGetRegexFirstLine(varType, varName);
                    Pattern p1 = Pattern.compile(getRegEx, Pattern.CASE_INSENSITIVE);
                    Matcher m1 = p1.matcher(line);
                    if (m1.find() == true)
                        fixNextLineForGet = true;
                }
                // need to handle case where the { is not on same line
                else if (line.indexOf(varName) == -1 && line.indexOf(';') == -1) {
                    if (line.contains("{") == false) {
                        // is not expected.
                        System.out.println("Error:  setter for this guy is possibly not right --> " + varDecl);
                    }
                } else {
                    // time for the fix.

                    int loc1 = line.indexOf(varName);
                    int loc2 = line.indexOf(';');

                    //return searchAppTable;
                    //return searchAppTable.getComponent();
                    /* line =
line.substring(0, loc1) + varName + "==null ? null : " +
 line.substring(loc1, loc2) + ".getComponent()" + line.substring(loc2);*/
                    String origLine = line;
                    line =
line.substring(0, loc1) + varRefName + "==null ? null : " + varRefName + ".getComponent()" + line.substring(loc2);

                    if (bDebug) {
                        System.out.println("--> [Applying Component Wrapper:getter]:");
                        System.out.println("Old line: " + origLine);
                        System.out.println("New Line: " + line);
                        System.out.println("<-- [End:Applying Component Wrapper]");
                    }

                    fixedCode.set(lineNo, line);
                    //                    line = line.substring(0, loc) +"ComponentReference.newUIComponentReference(" +varName  +");" +line.substring(loc);
                    isGetterFixed = true;
                }
            }

            if (isSetterFixed == false) {
                if (fixNextLineForSet == false) {
                    // in scanning mode
                    String setRegEx = getSetRegexFirstLine(varType, varName);
                    Pattern p1 = Pattern.compile(setRegEx, Pattern.CASE_INSENSITIVE);
                    Matcher m1 = p1.matcher(line);
                    if (m1.find() == true)
                        fixNextLineForSet = true;
                }
                // may need to skip to next line if the curly is on a line by itself.
                else if (line.indexOf("=") == -1 && line.indexOf(";") == -1) {
                    if (line.contains("{") == false) {
                        // is not expected.
                        System.out.println("Error:  setter for this guy is possibly not right --> " + varDecl);
                    }
                } else {
                    fixNextLineForSet = false;
                    // time for the fix.

                    int loc1 = line.indexOf("=") + 1;
                    int loc2 = line.indexOf(";");

                    if (loc2 == -1) {
                        String line2 = fixedCode.get(lineNo + 1);
                        line = line + " " + line2;
                        loc2 = line.indexOf(";");
                        if (loc2 != -1) {
                            iter.next();
                            iter.remove();
                        }
                    }

                    if (loc1 != -1 && loc2 != -1) {
                        //this.searchAppTable = searchAppTable;
                        //this.searchAppTable = ComponentReference.newUIComponentReference(searchAppTable);
                        String ws = getWhiteSpacePrefix(line);
                        String sIfStatement = ws + "if( this." + varRefName + " == null)\n    ";
                        /* line =
sIfStatement + ws + line.substring(0, loc1).trim() +
 " ComponentReference.newUIComponentReference(" +
 line.substring(loc1, loc2).trim() + ")" + line.substring(loc2);*/
                        String origLine = line;
                        line =
sIfStatement + ws + "this." + varRefName + "=" + " ComponentReference.newUIComponentReference(" +
 line.substring(loc1, loc2).trim() + ")" + line.substring(loc2);
                        fixedCode.set(lineNo, line);

                        if (bDebug) {
                            System.out.println("--> [Applying Component Wrapper:getter]:");
                            System.out.println("Old line: " + origLine);
                            System.out.println("New Line: " + line);
                            System.out.println("<-- [End:Applying Component Wrapper]");
                        }
                        isSetterFixed = true;
                    }
                }
            }

            lineNo++;
        }

        if (fixedDecl) {
            System.out.println("+++ Fix #5 Applied ++++++++++++++++++++++++++++++++++++++++++++++++++++");
            return true;

        } else {
            System.out.println("Review:  could not wrap component ---> " + varName + " in file " +
                               f.getAbsolutePath());
        }

        return false;
    }


    private String sExceptions = "";
    private int m_numExceptions = 0;

    private void logException(Exception e) {
        m_numExceptions++;

        sExceptions +=
                "\n@@ Exception # " + m_numExceptions + "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n";
        sExceptions += e.toString() + "\n";
        StackTraceElement[] element = e.getStackTrace();
        for (int i = 0; i < element.length; i++) {
            sExceptions += element[i].toString() + "\n";
        }
    }

    private static final Pattern whiteSpacePrefixPattern = Pattern.compile(whiteSpace);

    private String getWhiteSpacePrefix(String line) {
        Matcher m = whiteSpacePrefixPattern.matcher(line);

        if (m.find())
            return line.substring(m.start(), m.end());

        return "";
    }


    protected String getSummaryReportSubject() {
        return "Apply Component Wrapper";
    }

    protected String getSummaryReport() {
        return "just finished";
    }


    protected void processFile(File fName, boolean bDoADE) {
        processADFC_CONFIG(fName);
        m_reviewCount++;
    }


    @Override
    protected void crawlPeek(File f) {
        String sName = f.getAbsolutePath();
        if (sName.contains("InvoiceSecurity") || sName.contains("ExmSearchContextualEvent") ||
            sName.contains("InvoiceContextualAreaStateUtil.java") || sName.endsWith("ean.java") ||
            sName.contains("bean")) {
            registerBean(sName);
        }
    }
}
